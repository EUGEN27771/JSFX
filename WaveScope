desc:WaveScopeStereo v1-6
options:no_meter

import inc\Mouse3Full.jsfx-inc

slider1:1<0.01,12,0.00001>-Range(in sec)
slider2:0<0,4,1>-for mlt Hor Zoom
slider3:1<1,10,0.01>-Vertical Zoom
slider4:0<0,3,1{TimeLoop, MidiPitch, Tempo, Free} >-Sync Mode:
slider5:0<0,1,1{1 axis,2 axis}>-View Mode:
slider6:0<0,2,1{ 1 / 2 (Stereo), 1+2 / 3+4 (Multy) }>-Chan Mode:

in_pin:IN1
in_pin:IN2
in_pin:IN3
in_pin:IN4

@init

//**************************************************************************************************
ext_nodenorm = 1;
//----------------------------
/*Range не должен быть слишком большим - оптимально около 4 секунд.
Чем больше - тем больше нагрузка на процессор в этой версии, если это важно.
В следующих не будет иметь значения вообще(мы над этим работаем:)), но времени мало.
Но запас в слайдере оставлен специльно(нужен лично мне).*/
// incr. max. range - more CPU usage! This will be fixed in future versions)
max_range_sec = 12;
// coords and colors -- change if need
//x=40; y=10; w=960; h=580; // for scale
x=40; y=10; w=960; h=580; // witchout scale
r1=0.6; g1=0.3; b1=0.3; a1=0.2;
r2=0.3; g2=0.6; b2=0.3; a2=0.2; 

/***************************************************************************************************
*** DB2VAL - VAL2DB(from sdk, work faster, then 10^ and log10) *************************************
***************************************************************************************************/
function DB2VAL(x)
(
  exp((x)*0.11512925464970228420089957273422);
);
//----------------------------
function VAL2DB(x)
  local(v)
(
  x < 0.0000000298023223876953125 ? (
    -150; 
  ) : (
    v = log(x)*8.6858896380650365530225783783321;
    v < -150 ? -150 : v;
  );
);

/***************************************************************************************************
*** Waveform functions *****************************************************************************
***************************************************************************************************/
// == Init Wave ========================================= //
function wave.init(x,y,w,h, r1,g1,b1,a1, r2,g2,b2,a2, sbuf) 
(
  this.x = x; this.y = y; this.w = w; this.h = h; // coord 
  this.r1 = r1; this.g1 = g1; this.b1 = b1; this.a1 = a1; // ch1 color
  this.r2 = r2; this.g2 = g2; this.b2 = b2; this.a2 = a2; // ch2 color
  this.sbuf = sbuf; // samplebuffer memory offset, must NOT cross other used mem slots!
  this.view_mode = 1; // view mode 0=on one axis, 1=on sep axis
  this.Vzoom = 1;     // vertical zoom 
  this.div = 200;     // divfactor(smpls in peak)
);

// == Input samples to sbuf(sample buffer) ============== //
function wave.SamplesToBuffer(input1, input2)
  instance(sbuf, sbuf_sz, spos)   
(
  !this.Pause ? (
    spos>=sbuf_sz ? (
      //memset(sbuf,0,sbuf_sz); clear sbuf(if need) 
      spos=0;
    );
    
    sbuf[spos]   = input1;
    sbuf[spos+1] = input2;
    //------------------------------------
    spos+=2; // upd smpl pos counter
  );

);

function wave.draw_db_scale(axis, hlf_h)
  instance(x,y,w,h, Vzoom)
  local(db, db_str, str_w, str_h, str_hlf_h, v )
(
  db = 0;
  gfx_y = axis + hlf_h + gfx_texth;
  gfx_set(0.5,0.5,0.5);
  while(db > -150) (
    db_str = sprintf(#, "%.2f", db);
    gfx_measurestr(db_str, str_w, str_h);
    v = DB2VAL(db) * Vzoom * hlf_h;
    str_hlf_h = str_h/2; 
    gfx_y - (axis - str_hlf_h + v + 4) > str_h && gfx_y > axis + str_h + 4 ? (
      gfx_a = 0.9;
      gfx_x = x - 5 - str_w;
      gfx_y = axis - str_hlf_h - v;
      gfx_drawstr(db_str);
      gfx_x = x - 5 - str_w;
      gfx_y = axis - str_hlf_h + v;
      gfx_drawstr(db_str);
      
      gfx_a = 0.15;
      gfx_line(x, axis + v, x+w, axis + v);
      gfx_line(x, axis - v, x+w, axis - v);
    );
    
    db-=3;  
  );
);

// == Draw Wave ========================================= //
function wave.draw_waveform()
  instance(x,y,w,h, r1,g1,b1,a1, r2,g2,b2,a2, sbuf, view_mode, Vzoom, div)
  local(hlf_h, axis, axis1, axis2, peak_x, s, next_peak,
    cur_spl1, min_peak1, max_peak1, last_min_peak1, last_max_peak1,
    cur_spl2, min_peak2, max_peak2, last_min_peak2, last_max_peak2,
    chan, mouse_pos_val, str_w, str_h) 
( 
  
  // -- center axis --------
  hlf_h = h/2;
  axis  = y + hlf_h; // Это центральная ось!
  gfx_set(0.6,0.8,0.6,0.2);
  gfx_line(x, axis, x+w, axis);
  
  
  // -- dependent on the view_mode values --------
  view_mode = ViewMode.val ? (  // if view_mode = 1;
    axis1 = y + hlf_h - hlf_h/2;    // 1 - 2, так легче считать во всех случаях
    axis2 = y + hlf_h + hlf_h/2;
    gfx_a-=0.05;
    gfx_line(x, axis1, w, axis1);
    gfx_line(x, axis2, w, axis2);
    hlf_h = hlf_h/2;
    // -- db scale -----------
    wave.draw_db_scale(axis1, hlf_h); 
    wave.draw_db_scale(axis2, hlf_h); 
  ) : (                         // if view_mode = 0;
    axis1 = axis2 = axis;
    // -- db scale -----------
    wave.draw_db_scale(axis, hlf_h); 
  );
  
  
  //-- Get samples from sbuf, create peaks, draw waves -----
  peak_x = 0;x; // first peak x-position
  s = 0;      // sample cnt
  last_min_peak1 = last_max_peak1 = 0; // можно еще связать крайние точки
  last_min_peak2 = last_max_peak2 = 0; // можно еще связать крайние точки
  
  loop(w,
      // -- reset min-max peaks(v1-draw) ---------
      div > 1 ? (
        min_peak1 = min_peak2 = 10; max_peak1 = max_peak2 = -10; 
      ) : ( // if divfactor < 1 (less than one sample on one peak) 
        min_peak1 = min_peak2 = 0; max_peak1 = max_peak2 = 0;
      );
      
      // -- Create peaks from buffer samples -----
      next_peak = floor((peak_x+1) * div * 2 ); 
      while(s <= next_peak) (
        cur_spl1 = sbuf[s];    // ch1 spl
        cur_spl2 = sbuf[s+1];  // ch2 spl
        min_peak1 = min(min_peak1, cur_spl1);   // min peak1
        max_peak1 = max(max_peak1, cur_spl1);   // max peak1
        min_peak2 = min(min_peak2, cur_spl2);   // min peak2
        max_peak2 = max(max_peak2, cur_spl2);   // max peak2      
        s+=2; // upd cnt
      );
    
        // -- 1-channel
        min_peak1 = hlf_h * min_peak1 * Vzoom;
        max_peak1 = hlf_h * max_peak1 * Vzoom;
        min_peak1 = min( max(min_peak1, -hlf_h), hlf_h); // verify range
        max_peak1 = min( max(max_peak1, -hlf_h), hlf_h); // verify range
        // -- 2-channel
        min_peak2 = hlf_h * min_peak2 * Vzoom;
        max_peak2 = hlf_h * max_peak2 * Vzoom;
        min_peak2 = min( max(min_peak2, -hlf_h), hlf_h); // verify range
        max_peak2 = min( max(max_peak2, -hlf_h), hlf_h); // verify range    
      
      // -- Draw waveforms -----------------------
      gfx_set(r1, g1, b1, a1); //-- 1 peak line --
      gfx_line(x+peak_x, axis1-min_peak1, x+peak_x, axis1-max_peak1); // 1
      gfx_a += 0.3;            //-- 1 contour ----
      gfx_line(x+peak_x-1, axis1-last_min_peak1, x+peak_x, axis1-min_peak1, 1); // 1
      gfx_line(x+peak_x-1, axis1-last_max_peak1, x+peak_x, axis1-max_peak1, 1); // 1
      
      gfx_set(r2, g2, b2, a2); //-- 2 peak line --
      gfx_line(x+peak_x, axis2-min_peak2, x+peak_x, axis2-max_peak2); // 2
      gfx_a += 0.3;            //-- 2 contour ----
      gfx_line(x+peak_x-1, axis2-last_min_peak2, x+peak_x, axis2-min_peak2, 1); // 2
      gfx_line(x+peak_x-1, axis2-last_max_peak2, x+peak_x, axis2-max_peak2, 1); // 2    
    
      // -- store last peaks ---
      last_min_peak1 = min_peak1;
      last_max_peak1 = max_peak1;
      last_min_peak2 = min_peak2;
      last_max_peak2 = max_peak2;
  
      // -----------------------
      peak_x+=1; // to next x
  );

  //-- Draw frame if need ------------------------
  gfx_set(0.2,0.2,0.2,1);
  //gfx_rect(x-1,y,w+2,h+1,0);
  gfx_rect(x-1,y,w+2,h+1,0);
  //gfx_rect(x-1,y-1,w+1,h+3,0);
  
  // -- Mouse pos val ----------------------------
  // -- dependent on the view_mode values --------
  this.mouseIN() ? (
    ViewMode.val ? (  // if view_mode = 1;
      mouse_y < axis ? (
        mouse_pos_val = VAL2DB(abs((axis1 - mouse_y)/(hlf_h * Vzoom))); // one axis
        chan = " (L)";
      ) : (
        mouse_pos_val = VAL2DB(abs((axis2 - mouse_y)/(hlf_h * Vzoom))); // one axis
        chan = " (R)";
      );
    ) : (            // if view_mode = 0;
      mouse_pos_val = VAL2DB(abs((axis - mouse_y)/(hlf_h * Vzoom))); // one axis
      chan = " (L+R)";
    );
    // -------------
    mouse_pos_val = strcat( sprintf(#, "%.2f", mouse_pos_val), " dB"); // "%.2f" - variant
    mouse_pos_val =  strcat(mouse_pos_val, chan);
    gfx_measurestr(mouse_pos_val, str_w, str_h); // val w, val h
    gfx_x = x + w - 10 - str_w; gfx_y = y + 30;
    gfx_set(0.6, 0.8, 0.6, 1);
    gfx_drawstr(mouse_pos_val); 
  );
  
  // -- Info -------------------------------------
  gfx_set(0.6, 0.8, 0.6, 1);
  gfx_setfont(1,"Calibri", 14);
  gfx_x = x + 4; gfx_y = y + 4;
  gfx_drawnumber(range_spls, 0);
  gfx_drawstr(" samples");
  this.Pause ? gfx_drawstr(":  Pause!"); 

);



/***************************************************************************************************
*** Other functions ********************************************************************************
***************************************************************************************************/
// For info, debug etc(flag < 0 = string, flag >= 0 = number, ndigits)
// If x,y = 0 - draw in current position 
function ShowMsg(x,y, msg, flag)
(  
  x && y ? (gfx_x = x; gfx_y = y; );
  flag >= 0 ? gfx_drawnumber(msg, flag) : gfx_drawstr(msg);
);

// == For TimeLoop Mode ================================= //
function LoopMode.GetRange()
  local(play_step)
  instance(last_play_pos, last_samplesblock, range_sec)
(
  play_step = play_position - last_play_pos;
  play_state && play_step < 0 ? (
   //range_start = play_position;
   //range_end = last_play_pos + last_samplesblock/srate;
   range_sec = -play_step + last_samplesblock/srate;
   wave.spos = 0; // reset position to loop start!!!
  );
  last_play_pos = play_position;
  last_samplesblock = samplesblock;
  range_sec; // ret range
);

// == For Midi Mode ===================================== //
function MidiMode.GetRange()
  local(offset,msg1,msg2,msg3)
  instance(range_sec, note, freq)
(
  while (midirecv(offset,msg1,msg2,msg3)) (
     (msg1&240)==$x90 && msg3!=0 ? (
       note = msg2;
       freq = (2^((note-69)/12)) * 440;   // v1
       //freq = 2^(note/12+3.031);        // v2
       //freq = (1.05946^msg2) * 8.17742; // v3
       range_sec = 1/freq;
     );
     midisend(offset,msg1,msg2,msg3); // passthrough other events
  );
  range_sec; // ret range
);


//**************************************************************************************************
//**************************************************************************************************
// Very simple slider-linked button - only for label-sliders buttons! 
function btn_New(x,y,w,h, r,g,b,a, lbl, sldr_idx, val, maxval)
(
  this.x = x; this.y = y; this.w = w; this.h = h; // coord
  this.r = r; this.g = g; this.b = b; this.a = a; // color
  this.lbl = lbl;
  this.sldr_idx = sldr_idx;
  this.val = val;
  //this.minval = minval; 
  this.maxval = maxval;
);
//-----------------
function btn_Draw()
  instance(x,y,w,h, r,g,b,a, lbl, sldr_idx, val, maxval)
  local(offs)
(  
  // --- get-set value -------
  this.mouseClick() ? (
    val < maxval ? slider(sldr_idx)+=1 : slider(sldr_idx) = 0; // minval = 0 
    val =  slider(sldr_idx);
    slider_automate(2 ^ (sldr_idx-1));
  );
  
  //val != slider(sldr_idx) ? val = slider(sldr_idx); // for automation vis
  
  // --- draw ----------------
  gfx_set(r,g,b,a);
  gfx_rect(x,y,w,h,0);
  offs = h - gfx_texth;
  gfx_a = 1;  
  gfx_x = x + offs; gfx_y = y + offs/2;
  gfx_drawstr(lbl);
  gfx_drawstr( strcpy_fromslider( #, slider(sldr_idx) ) );

);



//*******************************************************************************
//*******************************************************************************
// function args = (x,y,w,h, r1,g1,b1,a1, r2,g2,b2,a2, sbuf) !!!
wave.init(x,y,w,h, r1,g1,b1,a1, r2,g2,b2,a2, 0);

//------------------------------------------------------------------------------
// function args = (x,y,w,h,       r,g,b,a,        lbl,         sldr_idx, val, maxval)
SyncMode.btn_New( 10,10,140,20, 0.6,0.8,0.6,0.4, "Sync Mode: ",    4,      0,   3);
ViewMode.btn_New(160,10,120,20, 0.6,0.8,0.6,0.4, "View Mode: ",    5,      0,   1);
ChanMode.btn_New(210,10,180,20, 0.6,0.8,0.6,0.4, "Channel Mode: ", 6,      0,   1);


@slider
range_sec = slider1;
wave.Vzoom = slider3;
SyncMode.val = slider4;
ViewMode.val = slider5;
ChanMode.val = slider6;



@block

// TimeLoop Mode ---------------------------------
SyncMode.val == 0 ? (
  range_sec = LoopMode.GetRange();  
  while(range_sec > max_range_sec + 0.001) ( range_sec*=0.5 ); // verify range

);

// Midi Pitch Mode -------------------------------
SyncMode.val == 1 ? (
  range_sec = MidiMode.GetRange();
  range_sec *= 2^(slider2); // multiply
);

// Test tempo-sync - range -----------------------
SyncMode.val == 2 ? (
  range_sec = 60/tempo * 2^(slider2);
  while(range_sec > max_range_sec + 0.001) ( range_sec*=0.5 ); // 4.001
);

// Free mode -------------------------------------
SyncMode.val == 3 ? (
    range_sec = slider1;
);


//-- Verify Range --------------------------------
range_sec <= 0 ? range_sec = 1;
slider1 = range_sec; // range_sec to slider
range_spls = floor(range_sec * srate + 0.5); // Range to samples
SyncMode.val == 1 ? while(range_spls*0.5<wave.w) ( range_spls*=2 );  // Только для миди?


//-- Update Wave values(divfactor and sbuffer size) ---------
wave.div = range_spls/wave.w; // division factor
wave.sbuf_sz = range_spls*2;  // wave samplebuffer size(1-2 channels)

@sample
ChanMode.val ? ( 
  // ChanMode  = "1+2 / 3+4"
  input1 = (spl0 + spl1) * 0.5;
  input2 = (spl2 + spl3) * 0.5;
) : (
  // ChanMode  = "1 / 2"
  input1 = spl0;
  input2 = spl1;
);  

// ChanMode  = "1 + 2 - Mono"  - не используется
// input1 = input2 = (spl0 + spl1) * 0.5; 

wave.SamplesToBuffer(input1, input2);

@gfx 800 400

gfx_getchar(); // request mouse_cap to be set even when mouse button not down

//***************************************************************
//-- Zoom  ---------------------------------------
function wave.GetMouse()
  local(K)
(
  //-- H Zoom -----------------------
  mouse_wheel ? (
    // MIDI,Tempo Sync Mode ---
    SyncMode.val == 1 || SyncMode.val == 2 ? (
      slider2 -= sign(mouse_wheel);
      slider2 = max(min(slider2,6),0);
    );
    // Free mode ---------
    SyncMode.val == 3 ? (
      mouse_cap&4 ? K = 1.01 : K = 1.1;
      mouse_wheel<0 ? slider1 *= K;
      mouse_wheel>0 ? slider1 /= K;
      slider1 = max(min(slider1, max_range_sec), 0.001);
    );
  );  
  
  //-- V Zoom -----------------------
  wave.mouseDown() ? (         // Capture wave
    wave.isCaptd = 1;
    wave.cap_x = mouse_x;
    wave.cap_y = mouse_y;
    wave.Vzoom.cap_val = wave.Vzoom;
  );
  //------
  mouse_up ? wave.isCaptd = 0; // reset Captd state
  
  //------
  wave.isCaptd ? (
    wave.Vzoom = wave.Vzoom.cap_val + (mouse_down_y-mouse_y)/150;
    wave.Vzoom = min(max(wave.Vzoom,1),10 );
    slider3 = wave.Vzoom;
  );
  //------
  wave.mouseRClick() ? wave.Pause = !wave.Pause;

);

//-- Upd coord  ----------------------------------
function UpdateCoord()
(  
  wave.w = max(520, gfx_w-wave.x-10);
  wave.h = max(160, gfx_h-wave.y-10);
    
  SyncMode.x = wave.x + wave.w - SyncMode.w - 4;     // upd sync x
  ViewMode.x = SyncMode.x - ViewMode.w - 4; // upd view x
  ChanMode.x = ViewMode.x - ChanMode.w - 4; // upd chan x
  
  SyncMode.y = ViewMode.y = ChanMode.y = wave.y + 4;     // upd y  
  
);

//-- Draw -------------------------
function Draw()
( 
  UpdateCoord();
  wave.GetMouse();
  // -- buttons ----
  SyncMode.btn_Draw();
  ViewMode.btn_Draw();
  ChanMode.btn_Draw();
  // -- waveform ---
  wave.draw_waveform();
);


//***************************************************************
/* Можно не морочить голову с пересчетами, а просто снизить на 10-15 фпс на больших рангах!
Все равно там фпс похеру абсолютно. Как в Рипере при записи. Пока пусть так будет.*/
GetMouseState();
Draw();
SetMouseLastState();
//***************************************************************
